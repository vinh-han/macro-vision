
type Food_item struct {
	Name string `json:"name"`
	Link string
}

func scrape()

func main() {
	var food_items []Food_item
	var err error
	var byte_value []byte

	byte_value, err = os.ReadFile(scraped_filename)
	if err != nil {
		fmt.Println(err.Error())
		panic(err)
	}

	json.Unmarshal(byte_value, &food_items)

	for _, item := range food_items {
		if item.Name == "" {
			continue
		}
		// replacing spaces with underscores and normalizing the names
		item_image_name := strings.ReplaceAll(item.Name, " ", "_")
		item_image_name = norm.NFC.String(item_image_name)

		item_image_filename := removeDiacritics(item_image_name)
		item_image_filename = fmt.Sprintf("%s/%s.jpg", image_folder, item_image_filename)
		out, err := os.Create(item_image_filename)
		if err != nil {
			fmt.Println(err)
			panic(err)
		}
		defer out.Close()
		fmt.Printf("downloading %s\n", item_image_name)
		download_image(item)
		fmt.Println("done")
		item.Image_url = item_image_filename
		fmt.Printf("waiting for %n seconds", wait_per_req_s)
		// wait per image, respecc robots.txt
		time.Sleep(time.Duration(time.Second * time.Duration(wait_per_req_s)))

	}
	byte_value, err = json.Marshal(food_items)
	if err != nil {
		fmt.Println(err)
		panic(err)
	}

	os.WriteFile(cleaned_filename, byte_value, 0770)
}

func removeDiacritics(s string) string {
	t := norm.NFD.String(s)

	// Filter out non-spacing marks (diacritics)
	b := make([]rune, 0, len(t))
	for _, r := range t {
		if unicode.Is(unicode.Mn, r) {
			continue // skip diacritical marks
		}
		b = append(b, r)
	}
	return string(b)
}

func FullImageURL(thumbURL string) string {
	if !strings.Contains(thumbURL, "/thumb/") {
		return thumbURL // already full
	}
	parts := strings.Split(thumbURL, "/")
	// remove "thumb" part
	for i, p := range parts {
		if p == "thumb" {
			parts = append(parts[:i], parts[i+1:]...)
			break
		}
	}
	// remove last part (size-filename)
	parts = parts[:len(parts)-1]
	return strings.Join(parts, "/")
}

func download_image(item Food_item) error {
	image_url := FullImageURL(item.Image_url)

	request, err := http.NewRequest("GET", image_url, nil)
	if err != nil {
		return err
	}
	request.Header.Set("User-Agent", user_agent)
	request.Header.Set("Accept-Encoding", "gzip")

	resp, err := http.DefaultClient.Do(request)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return err
	}
	return nil
}
